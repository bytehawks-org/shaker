#!/usr/bin/env bash
#


shaker_base_path() {
    local BH_SHAKER_CURRENT_SCRIPT_DIR="$(dirname "$(realpath "${BASH_SOURCE[0]}")")"
    export BH_SHAKER_BASE_FOLDER="${BH_SHAKER_CURRENT_SCRIPT_DIR%/lib}"
}

shaker_assets_path() {
    export BH_SHAKER_ASSETS_FOLDER="${BH_SHAKER_BASE_FOLDER}/assets"
}

shaker_lib_path() {
    export BH_SHAKER_LIB_FOLDER="${BH_SHAKER_BASE_FOLDER}/lib"
}





##############################################################################
#
# Function: normalize_boolean
#
# Normalizes various boolean-like input values to "true" or "false" strings.
#
# Arguments:
#   $1 - The input value to normalize. Recognized values include:
#          - "yes", "y", "1", "true" as TRUE values.
#          - "no", "n", "none", "0", "false" as FALSE values.
#        All values are treated as case-insensitively.
#
# Outputs:
#   Echoes "true" if the input represents a true value.
#   Echoes "false" if the input represents a false value or is unrecognized.
#
# Returns:
#   0 if the input is recognized as a boolean value
#   1 if the input is unrecognized
#
# Examples:
#   MY_VAR="Y"   -> normalize_boolean "${MY_VAR}" -> outputs "true", Returns 0
#   MY_VAR="0"  -> normalize_boolean "${MY_VAR}" -> outputs "false", Returns 0
#   MY_VAR="Na" -> normalize_boolean "${MY_VAR}" -> outputs "false", Returns 1
#
# Notes: 
#   Bash 4.0+ is required for case modification features.
#
##############################################################################
normalize_boolean() {

    local input="${1:-}"
    local lower_input="${input,,}"

    case "$lower_input" in
        true|yes|y|1)
            echo "true"
            return 0
            ;;
        false|no|n|none|0)
            echo "false"
            return 0
            ;;
        *)
            echo "false"
            return 1
            ;;
    esac

}


###############################################################################
#
# Function: normalize_case
#
# Converts the input string to either lowercase or uppercase based on the   
# specified case argument.
#
# Usage:
#   normalize_case <case> <string>
#
# Arguments:
#   <case>   The desired case for the output string. Accepted values are
#            "lower" for lowercase conversion and "upper" for uppercase conversion.
#   <string> The string to be converted.
#
# Behavior:
#   - If running on Bash 4.0 or newer, uses parameter expansion for efficiency.
#   - If running on older Bash versions (e.g., Bash 3.x as on macOS), falls back 
#     to using 'tr'.
#
# Returns:
#   Prints the converted string to stdout.
#
###############################################################################
normalize_case() {

    if [[ "$#" -ne 2 ]]; then
        log_event "error" "normalize_case requires exactly 2 arguments: <case> <string>"
        return 1
    fi

    local output_case="$1" 
    local input="$2"

    if [ -n "${BASH_VERSINFO[0]}" ] && [ "${BASH_VERSINFO[0]}" -ge 4 ]; then

        local normalized_output_case="${output_case,,}"

        if [ "${normalized_output_case}" == "lower" ]; then
            echo "${input,,}"
            return 0
        elif [ "${normalized_output_case}" == "upper" ]; then
            echo "${input^^}"
            return 0
        else
            log_event "error" "normalize_case: Invalid case argument '$case'. Use 'lower' or 'upper'."
            return 1
        fi
    
    else 

        local normalized_output_case="$(echo "${output_case}" | tr '[:upper:]' '[:lower:]')"

        if [ "${normalized_output_case}" == "lower" ]; then
            echo "$input" | tr '[:upper:]' '[:lower:]'
            return 0
        elif [ "${normalized_output_case}" == "upper" ]; then
            echo "$input" | tr '[:lower:]' '[:upper:]'
            return 0
        else
            log_event "error" "normalize_case: Invalid case argument '$case'. Use 'lower' or 'upper'."
            return 1
        fi

    fi
}



###############################################################################
#
# Function: cleanup_bh_shaker_env_vars
#
# Removes all environment variables that start with the prefix "BH_SHAKER_".
#
# During cleanup, an informational message is logged for each variable removed
# or for the list of removed variables, using the log_event function.
#
# Note:
# - Requires the log_event function to be defined for event logging.
# - On Bash >= 3.0, uses the ${!BH_SHAKER_@} expansion to get the list of
#   variables to remove.
# - On older versions, uses compgen and grep to identify the variables.
#
###############################################################################
cleanup_bh_shaker_env_vars() {
    # Controllo versione Bash (>= 3.0 supporta ${!var@})
    if [ -n "${BASH_VERSINFO[0]}" ] && [ "${BASH_VERSINFO[0]}" -ge 3 ]; then
        # Recuperiamo la lista in un array (o stringa espansa) per sicurezza
        local vars_to_unset="${!BH_SHAKER_@}"
        
        if [ -n "$vars_to_unset" ]; then
            # Nota: qui passiamo la stringa alla tua funzione error/info per loggare
            # Assumiamo che 'error' o 'info' gestiscano bene le stringhe
            # Se la funzione 'error' non esiste, usa 'echo' o 'stderr_print'
            log_event "info" "Pulizia variabili: $vars_to_unset"
            
            # IMPORTANTE: Qui le virgolette NON vanno messe per permettere a unset
            # di vedere ogni variabile come argomento separato.
            unset $vars_to_unset
        fi
    else
        # Fallback per shell molto vecchie (uso di compgen)
        for var in $(compgen -v | grep '^BH_SHAKER_'); do
            log_event "info" "Pulizia variabile: $var"
            unset "$var"
        done
    fi
}



###############################################################################
#
# Function: debug_bh_shaker_env_vars
#
# Prints all environment variables that start with 'BH_SHAKER_' and their 
# values for debugging purposes.
# Uses advanced parameter expansion if Bash version >= 3, otherwise falls back 
# to using 'compgen' and 'grep'.
#
# Usage: debug_bh_shaker_env_vars
#
###############################################################################
debug_bh_shaker_env_vars() {

    log_event "debug" "BH_SHAKER_ available environment variables:"

    if [ -n "${BASH_VERSINFO[0]}" ] && [ "${BASH_VERSINFO[0]}" -ge 3 ]; then
        for var in "${!BH_SHAKER_@}"; do
            log_event "debug" "Environment variable: $var=${!var}"
        done
    else
        for var in $(compgen -v | grep '^BH_SHAKER_'); do
            log_event "debug" "Environment variable: $var=${!var}"
        done
    fi

}



##############################################################################
#
# Function: print_welcome_banner
#
# Prints the welcome banner if the banner file exists and banner display 
# is not disabled with the BH_SHAKER_DISABLE_BANNER environment variable.
# 
# The function checks for the presence of a banner file at the path specified 
# by the BH_SHAKER_ASSETS_FOLDER environment variable. 
# If the file exists and the BH_SHAKER_DISABLE_BANNER environment variable 
# is not set to a true value (as determined by the normalize_boolean function),
# the banner is displayed using base system command 'cat'.
# If banner display is disabled, a message is printed indicating this.
# If the banner file does not exist, a message is printed indicating the 
# issing file.
#
##############################################################################
print_welcome_banner() {

    local hide_banner="${BH_SHAKER_DISABLE_BANNER:-false}"

    if [[ -f "${BH_SHAKER_ASSETS_FOLDER}/banner.txt" ]]; then
        if [[ $(normalize_boolean "${hide_banner}") == "false" ]]; then
            cat "${BH_SHAKER_ASSETS_FOLDER}/banner.txt"
            return 0
        else
            echo "Banner display is disabled via BH_SHAKER_DISABLE_BANNER environment variable."
            return 0
        fi
    else
        echo "Banner file not found at ${BH_SHAKER_ASSETS_FOLDER}/banner.txt"
        return 1
    fi

}

